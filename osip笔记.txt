一、笔记
1.匹配transaction的规则:
	对于请求消息：收到的消息和已存在的transactions中的transaction相比较，
	              topvia的brach、host和port字段、CSeq的Method字段都相等，则认为是同一个transaction
	对于回复消息：收到的消息和transactions中的transaction相比较，topvia的
	              branch、CSeq的Method字段都相等，则认为是同一个transaction
	详见:osip_transaction_find
	
2.回复invite 200OK的ACK的via branch和invite的via branch branch不相同
  Cancel的via branch和invite的via branch相同
  
3.invite消息没有to tag，180ring就会携带to tag了
  发出invite时，不会初始化eXosip_dialog_t。收到180ring时，初始化eXosip_dialog_t。
  
4.匹配dialog(会话)的规则:
  4.1UAS的匹配规则(osip_dialog_match_as_uas)  ==>主要是匹配callid和from tag(remote tag)
  1.先匹配callid
  2.再匹配from/to tag，匹配规则如下
      1)如果收到的消息没有from/to tag，匹配失败
	  2)已存在的dialog中没有remote tag，使用收到的消息的from/to头域中的from_uri/to_uri和
	    dialog的remote_uri/local_uri比较，相等则匹配成功，否则失败
	  3)收到的消息有from tag且dialog有remot tag，用from tag和remote tag相匹配，相等则匹配成功，否则失败。
  
  
二、RFC3261:
	1.sip逻辑上是分层的，由下到上:
	Transaction User(TU)
	事务层
	传输层
	编码层
	
	2.dialog含义
	1)only invite can create a dialog
	2)is peer-to-peer
	3)identified by a callid, local tag and a remote tag.
	
	3.transaction含义
	1)initial request + last response
	2)if request is invite, and the last response is non-2xx, Ack is part of this transaction.
	  elif request is invite, last response is 2XX, Ack for this 2XX is another transaction.
	  
	
	
三、主要数据结构：
	osip_dialog_t <1对1 ==> eXosip_dialog_t <多对1 ==> eXosip_call_t->c_dialogs <多对1 ==> eXosip_t->j-calls

	 //收到invite，构建uas dialog. 收到180/notify/200OK for subscribe, 构建uac dialog
	struct osip_dialog {
		char *call_id;         /**< Call-ID*/
		char *local_tag;       /**< local tag */ //对uas,是to tag. 对uac,是from tag
		char *remote_tag;      /**< remote tag */ //对uas，是from tag. 对uac，是to tag
		char *line_param;      /**< line param from request uri for incoming calls */
		osip_list_t route_set;         /**< route set */
		int local_cseq;                /**< last local cseq */
		int remote_cseq;               /**< last remote cseq*/
		osip_to_t *remote_uri;         /**< remote_uri */ //对uas，是from tag. 对uac,是to tag
		osip_from_t *local_uri;        /**< local_uri */  //与remote_uri相反
		osip_contact_t *remote_contact_uri;
									   /**< remote contact_uri */
		int secure;                    /**< use secure transport layer */

		osip_dialog_type_t type;       /**< type of dialog (CALLEE or CALLER) */
		state_t state;                 /**< DIALOG_EARLY || DIALOG_CONFIRMED || DIALOG_CLOSED */
		void *your_instance;           /**< for application data reference */
	};
	
	//收到invite，构建uas dialog. 收到180/notify/200OK for subscribe, 构建uac dialog
	//相比osip_dialog_t，eXosip_dialog_t有了自己的状态，存在最新的收发消息是上面(d_inc_trs/d_out_trs)
     struct eXosip_dialog_t {
		int d_id;
		osip_dialog_t *d_dialog;    /* active dialog */

		time_t d_session_timer_start;       /* session-timer helper */
		int d_session_timer_length;
		int d_refresher;
		int d_session_timer_use_update;

		time_t d_timer;
		int d_count;
		osip_message_t *d_200Ok;
		osip_message_t *d_ack;

		osip_list_t *d_inc_trs; //在会话内收到下述消息，会设置d_inc_trs。==>bye,cancel,reinvite,subscribe,notify,message
		osip_list_t *d_out_trs; //发送会话内的非invite消息时，会设置d_out_trs
		int d_retry;                /* avoid too many unsuccessful retry */
		int d_mincseq;              /* remember cseq after PRACK and UPDATE during setup */

		eXosip_dialog_t *next;
		eXosip_dialog_t *parent;
  };
  
	//发送invite/notify或收到invite时，会初始化eXosip_call_t
	struct eXosip_call_t {
		int c_id; //上行会话和下行会话 会初始化两个eXosip_call_t，各有要给c_id
		eXosip_dialog_t *c_dialogs; //上行:收到invite，下行:收到180ring的时候，会使用invite或180消息初始化一个
										//eXosip_dialog_t，放入c_dialogs。主要是初始化eXosip_dialog_t->d_dialog
										//eXosip_dialog_t->d_inc_trs/d_out_trs没有赋值，只分配了一块空间
										
		osip_transaction_t *c_inc_tr;  //收到invite时，将invite transaction存在c_inc_tr
		osip_transaction_t *c_out_tr;  //发invite或notify时,会将out transaction赋给c_out_tr
		int c_retry;                /* avoid too many unsuccessful retry */
		void *external_reference;

		time_t expire_time;

		eXosip_call_t *next;
		eXosip_call_t *parent;
	};
  
 struct eXosip_t {     //全局结构体(excontext)
#ifndef MINISIZE
    struct eXosip_stats statistics;
    struct eXosip_counters average_transactions;
    struct eXosip_counters average_registrations;
    struct eXosip_counters average_calls;
    struct eXosip_counters average_publications;
    struct eXosip_counters average_subscriptions;
    struct eXosip_counters average_insubscriptions;
#endif

    struct eXtl_protocol eXtl_transport;
    void *eXtludp_reserved;
    void *eXtltcp_reserved;
#ifndef DISABLE_TLS
    void *eXtltls_reserved;
    void *eXtldtls_reserved;
#endif
    void *tunnel_handle;
    char transport[10];
    char *user_agent;

    eXosip_reg_t *j_reg;        /* my registrations */
    eXosip_call_t *j_calls;     /* my calls        */ //发invite/notify或者收invite时，会初始化一个eXosip_call_t，放入j_calls
#ifndef MINISIZE
    eXosip_subscribe_t *j_subscribes;   /* my friends      */
    eXosip_notify_t *j_notifies;        /* my susbscribers */
    eXosip_pub_t *j_pub;        /* my publications  */
#endif
    osip_list_t j_transactions;

    osip_t *j_osip;
    int j_stop_ua;
#ifndef OSIP_MONOTHREAD
    void *j_cond;
    void *j_mutexlock;
    void *j_thread;
    jpipe_t *j_socketctl;
    jpipe_t *j_socketctl_event;
#endif
    int max_message_to_read;
    long int max_read_timeout;
    
    osip_fifo_t *j_events;

    jauthinfo_t *authinfos;

    struct timeval cc_timer;
    struct timeval ka_timer;
    int ka_interval;
    char ka_crlf[5];
    int ka_options;
    int learn_port;
    int use_rport;
    int remove_prerouteset;
    int dns_capabilities;
    int enable_dns_cache;
    int dscp;
    int register_with_date;
    int autoanswer_bye;
    int ipv6_enable;
    char ipv4_for_gateway[256];
    char ipv6_for_gateway[256];
    struct eXosip_dns_cache dns_entries[MAX_EXOSIP_DNS_ENTRY];
    struct eXosip_account_info account_entries[MAX_EXOSIP_ACCOUNT_INFO];
    struct eXosip_http_auth http_auths[MAX_EXOSIP_HTTP_AUTH];

    /* udp pre-config */
    char udp_firewall_ip[64];
    char udp_firewall_port[10];

    /* tcp pre-config */
    char tcp_firewall_ip[64];
    char tcp_firewall_port[10];

    /* tls pre-config */
    char tls_firewall_ip[64];
    char tls_firewall_port[10];
    int tls_verify_client_certificate;
    eXosip_tls_ctx_t eXosip_tls_ctx_params;
    char tls_local_cn_name[128];
    char tls_client_local_cn_name[128];

    /* dtls pre-config */
    char dtls_firewall_ip[64];
    char dtls_firewall_port[10];

    CbSipCallback cbsipCallback;
    int masquerade_via;
    int auto_masquerade_contact;
    int reuse_tcp_port;
    int use_ephemeral_port;
    int enable_outbound;
    char oc_local_address[64];
    int oc_local_port_range[2];
    int oc_local_port_current;

    CbSipWakeLock cbsipWakeLock;
    int outgoing_wake_lock_state;
    int incoming_wake_lock_state;

    char sip_instance[37]; /* can only be used if ONE excontext is used for ONE registration only */
    char default_contact_displayname[256];
  }
 
 
四、主要函数说明

/*****初始化部分的函数  start*********/
//协议栈通过该函数将当前事件(eXosip_event_t)上报给业务层，业务层可以开启一个线程循环调用该函数来接收事件的到来
eXosip_event_t *eXosip_event_wait (struct eXosip_t * excontext, int tv_s, int tv_ms)

//协议栈向业务层上报事件的函数
int _eXosip_event_add (struct eXosip_t *excontext, eXosip_event_t * je)

//该函数做的事情:socket, bind, listen, put listen socket to select, recvfrom, handle_msg
int eXosip_listen_addr (struct eXosip_t *excontext, int transport, const char *addr, int port, int family, int secure)

//单线程的时候，将接收socket放到select，socket有消息到来触发select。执行read_message->handle_message等
//一系列函数。执行过程中，会根据不同的消息通知上层业务相关的业务到来，或者向transaction->transactionff
//中写数据，之后osip_***_execute这些状态机函数会从transactionff中取数据，执行相应的状态机处理流程。
//支持多线程时，相比单线程多了一步，会将wakeup读端也加入select函数中(代码在_eXosip_read_message中)，
//如果wakeup读端收到消息，就认为状态机函数被激活，激活select，退出_eXosip_read_message，以便迅速执行状态机
//函数
//有个疑问，多线程时，多个线程调_eXosip_read_message，多个select同时监听同一个接收接收socket，是什么现象?
//(也可能是我代码理解错了?，看代码，支持多线程，需要多线程调用eXosip_execute，而eXosip_execute里面会监听接收socket)

//可以把读消息和状态机执行函数分开，1个线程专门读socket(这些线程不需要eXosip_t)。
//n个线程专门调用状态机执行函数(这n个线程都有一个自己的eXosip_t)
//读消息线程根据sip消息的from、to头域做hash，得到eXosip_t[i]，以此确定通知
//哪一个状态机处理线程处理相应的状态
//使用wakeup_socket来做通知，对wakeup_socket的监听从_eXosip_read_message中挪出来，放到eXosip_execute中,
//_eXosip_read_message只监听接收socket的消息并处理
int eXosip_execute (struct eXosip_t *excontext);
int _eXosip_read_message (struct eXosip_t *excontext, int max_message_nb, int sec_max, int usec_max)


//更新新建call和dialog的cid和did
void _eXosip_update (struct eXosip_t *excontext);

//该函数是构建一个回复消息，将request消息的from,to,vias,cseq等消息拷贝给要构建的response
int _eXosip_build_response_default (struct eXosip_t *excontext, osip_message_t ** dest, osip_dialog_t * dialog, int status, osip_message_t * request);

//设置response的contact, record-route(把request的record-route拷贝到response消息上)
int _eXosip_complete_answer_that_establish_a_dialog (struct eXosip_t *excontext, osip_message_t * response, osip_message_t * request);

//业务线程等待协议栈上报eXosip_event_t
eXosip_event_t *eXosip_event_wait (struct eXosip_t * excontext, int tv_s, int tv_ms)

//触发
_eXosip_wakeup (struct eXosip_t *excontext);