一、笔记
1.匹配transaction的规则:
	对于请求消息：收到的消息和已存在的transactions中的transaction相比较，
	              topvia的brach、host和port字段、CSeq的Method字段都相等，则认为是同一个transaction
	对于回复消息：收到的消息和transactions中的transaction相比较，topvia的
	              branch、CSeq的Method字段都相等，则认为是同一个transaction
	详见:osip_transaction_find
	
2.回复invite 200OK的ACK的via branch和invite的via branch branch不相同
  Cancel的via branch和invite的via branch相同
  
3.invite消息没有to tag，180ring就会携带to tag了
  发出invite时，不会初始化eXosip_dialog_t。收到180ring时，初始化eXosip_dialog_t。
  
4.匹配dialog(会话)的规则:
  4.1UAS的匹配规则(osip_dialog_match_as_uas)  ==>主要是匹配callid和from tag(remote tag)
  1.先匹配callid
  2.再匹配from/to tag，匹配规则如下
      1)如果收到的消息没有from/to tag，匹配失败
	  2)已存在的dialog中没有remote tag，使用收到的消息的from/to头域中的from_uri/to_uri和
	    dialog的remote_uri/local_uri比较，相等则匹配成功，否则失败
	  3)收到的消息有from tag且dialog有remot tag，用from tag和remote tag相匹配，相等则匹配成功，否则失败。
  
  
二、RFC3261:
	还没看  2018.10.31
	
	
三、主要数据结构：
	  struct osip_dialog {
		char *call_id;         /**< Call-ID*/
		char *local_tag;       /**< local tag */ //对uas,是to tag. 对uac,是from tag
		char *remote_tag;      /**< remote tag */ //对uas，是from tag. 对uac，是to tag
		char *line_param;      /**< line param from request uri for incoming calls */
		osip_list_t route_set;         /**< route set */
		int local_cseq;                /**< last local cseq */
		int remote_cseq;               /**< last remote cseq*/
		osip_to_t *remote_uri;         /**< remote_uri */ //对uas，是from tag. 对uac,是to tag
		osip_from_t *local_uri;        /**< local_uri */  //与remote_uri相反
		osip_contact_t *remote_contact_uri;
									   /**< remote contact_uri */
		int secure;                    /**< use secure transport layer */

		osip_dialog_type_t type;       /**< type of dialog (CALLEE or CALLER) */
		state_t state;                 /**< DIALOG_EARLY || DIALOG_CONFIRMED || DIALOG_CLOSED */
		void *your_instance;           /**< for application data reference */
  };
  
     struct eXosip_dialog_t {
		int d_id;
		osip_dialog_t *d_dialog;    /* active dialog */

		time_t d_session_timer_start;       /* session-timer helper */
		int d_session_timer_length;
		int d_refresher;
		int d_session_timer_use_update;

		time_t d_timer;
		int d_count;
		osip_message_t *d_200Ok;
		osip_message_t *d_ack;

		osip_list_t *d_inc_trs; //在会话内收到下述消息，会设置d_inc_trs。==>bye,cancel,reinvite,subscribe,notify,message
		osip_list_t *d_out_trs; //发送会话内的非invite消息时，会设置d_out_trs
		int d_retry;                /* avoid too many unsuccessful retry */
		int d_mincseq;              /* remember cseq after PRACK and UPDATE during setup */

		eXosip_dialog_t *next;
		eXosip_dialog_t *parent;
  };
  
    struct eXosip_call_t {
		int c_id; //上行会话和下行会话 会初始化两个eXosip_call_t，各有要给c_id
		eXosip_dialog_t *c_dialogs; //上行:收到invite，下行:收到180ring的时候，会使用invite或180消息初始化一个
										//eXosip_dialog_t，放入c_dialogs。主要是初始化eXosip_dialog_t->d_dialog
										//eXosip_dialog_t->d_inc_trs/d_out_trs没有赋值，只分配了一块空间
										
		osip_transaction_t *c_inc_tr;  //收到invite时，将invite transaction存在c_inc_tr
		osip_transaction_t *c_out_tr;  //发invite或notify时,会将out transaction赋给c_out_tr
		int c_retry;                /* avoid too many unsuccessful retry */
		void *external_reference;

		time_t expire_time;

		eXosip_call_t *next;
		eXosip_call_t *parent;
  };
  
 struct eXosip_t {     //全局结构体(excontext)
#ifndef MINISIZE
    struct eXosip_stats statistics;
    struct eXosip_counters average_transactions;
    struct eXosip_counters average_registrations;
    struct eXosip_counters average_calls;
    struct eXosip_counters average_publications;
    struct eXosip_counters average_subscriptions;
    struct eXosip_counters average_insubscriptions;
#endif

    struct eXtl_protocol eXtl_transport;
    void *eXtludp_reserved;
    void *eXtltcp_reserved;
#ifndef DISABLE_TLS
    void *eXtltls_reserved;
    void *eXtldtls_reserved;
#endif
    void *tunnel_handle;
    char transport[10];
    char *user_agent;

    eXosip_reg_t *j_reg;        /* my registrations */
    eXosip_call_t *j_calls;     /* my calls        */ //发invite/notify或者收invite时，会初始化一个eXosip_call_t，放入j_calls
#ifndef MINISIZE
    eXosip_subscribe_t *j_subscribes;   /* my friends      */
    eXosip_notify_t *j_notifies;        /* my susbscribers */
    eXosip_pub_t *j_pub;        /* my publications  */
#endif
    osip_list_t j_transactions;

    osip_t *j_osip;
    int j_stop_ua;
#ifndef OSIP_MONOTHREAD
    void *j_cond;
    void *j_mutexlock;
    void *j_thread;
    jpipe_t *j_socketctl;
    jpipe_t *j_socketctl_event;
#endif
    int max_message_to_read;
    long int max_read_timeout;
    
    osip_fifo_t *j_events;

    jauthinfo_t *authinfos;

    struct timeval cc_timer;
    struct timeval ka_timer;
    int ka_interval;
    char ka_crlf[5];
    int ka_options;
    int learn_port;
    int use_rport;
    int remove_prerouteset;
    int dns_capabilities;
    int enable_dns_cache;
    int dscp;
    int register_with_date;
    int autoanswer_bye;
    int ipv6_enable;
    char ipv4_for_gateway[256];
    char ipv6_for_gateway[256];
    struct eXosip_dns_cache dns_entries[MAX_EXOSIP_DNS_ENTRY];
    struct eXosip_account_info account_entries[MAX_EXOSIP_ACCOUNT_INFO];
    struct eXosip_http_auth http_auths[MAX_EXOSIP_HTTP_AUTH];

    /* udp pre-config */
    char udp_firewall_ip[64];
    char udp_firewall_port[10];

    /* tcp pre-config */
    char tcp_firewall_ip[64];
    char tcp_firewall_port[10];

    /* tls pre-config */
    char tls_firewall_ip[64];
    char tls_firewall_port[10];
    int tls_verify_client_certificate;
    eXosip_tls_ctx_t eXosip_tls_ctx_params;
    char tls_local_cn_name[128];
    char tls_client_local_cn_name[128];

    /* dtls pre-config */
    char dtls_firewall_ip[64];
    char dtls_firewall_port[10];

    CbSipCallback cbsipCallback;
    int masquerade_via;
    int auto_masquerade_contact;
    int reuse_tcp_port;
    int use_ephemeral_port;
    int enable_outbound;
    char oc_local_address[64];
    int oc_local_port_range[2];
    int oc_local_port_current;

    CbSipWakeLock cbsipWakeLock;
    int outgoing_wake_lock_state;
    int incoming_wake_lock_state;

    char sip_instance[37]; /* can only be used if ONE excontext is used for ONE registration only */
    char default_contact_displayname[256];
  }
 
 
四、主要函数说明

//先读消息，读到或超时未读到就接着执行下面的状态机函数，效率不高
//可以把读消息和状态机执行函数分开，m个线程专门读(这些线程不需要eXosip_t)。
//n个线程专门调用状态机执行函数(这n个线程可以一个自己的eXosip_t，一共n个)
//m个读线程根据sip消息的from、to头域做hash，得到eXosip_t[i]，以此确定通知
//哪一个状态机处理线程处理相应的状态
int eXosip_execute (struct eXosip_t *excontext);

//更新新建call和dialog的cid和did
void _eXosip_update (struct eXosip_t *excontext);

//该函数是构建一个回复消息，将request消息的from,to,vias,cseq等消息拷贝给要构建的response
int _eXosip_build_response_default (struct eXosip_t *excontext, osip_message_t ** dest, osip_dialog_t * dialog, int status, osip_message_t * request);

//设置response的contact, record-route(把request的record-route拷贝到response消息上)
int _eXosip_complete_answer_that_establish_a_dialog (struct eXosip_t *excontext, osip_message_t * response, osip_message_t * request);

//业务线程等待协议栈上报eXosip_event_t
eXosip_event_t *eXosip_event_wait (struct eXosip_t * excontext, int tv_s, int tv_ms)

//触发
_eXosip_wakeup (struct eXosip_t *excontext);